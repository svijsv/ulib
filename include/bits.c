// SPDX-License-Identifier: GPL-3.0-only
/***********************************************************************
*                                                                      *
*                                                                      *
* Copyright 2024 svijsv                                                *
* This program is free software: you can redistribute it and/or modify *
* it under the terms of the GNU General Public License as published by *
* the Free Software Foundation, version 3.                             *
*                                                                      *
* This program is distributed in the hope that it will be useful, but  *
* WITHOUT ANY WARRANTY; without even the implied warranty of           *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    *
* General Public License for more details.                             *
*                                                                      *
* You should have received a copy of the GNU General Public License    *
* along with this program. If not, see <http:// www.gnu.org/licenses/>.*
*                                                                      *
*                                                                      *
***********************************************************************/
// bits.h
// Operations on bitfields
// NOTES:
//   These are typed function versions of macros available in bits.h. Normally
//   they are included from that file and inlined, but if ULIB_BITOP_ENABLE_INLINED_FUNCTIONS
//   is 0 bits.c will need to be added to the source file list to be used and the
//   functions won't be inlined.
//
//   Not all macros have inlined function versions because not all would benefit
//   from them.
//
//   Many of the macros will act on the bit field directly, but with the
//   functions the field will need to be assigned by the caller (e.g.
//   'SET_BIT(f, x)' vs. 'f = set_bit_u32(f, x)'.
//
//   The only likely advantages of these functions is type checking and avoiding
//   the occasional cast or unintended integer promotion.
//
//   This file was partially generated by bits_c_gen.sh on Thu Jun 20 05:30:10 PM EDT 2024
//
#ifdef __cplusplus
 extern "C" {
#endif

#if ULIB_ENABLE_BITOPS
#ifndef _ULIB_BITS_H
# include "bits.h"
#endif


BITOP_FUNC_INLINE uint set_bit(uint field, uint bits) {
	return SET_BIT(field, bits);
}
BITOP_FUNC_INLINE uint8_t set_bit_u8(uint8_t field, uint8_t bits) {
	return SET_BIT(field, bits);
}
BITOP_FUNC_INLINE uint16_t set_bit_u16(uint16_t field, uint16_t bits) {
	return SET_BIT(field, bits);
}
BITOP_FUNC_INLINE uint32_t set_bit_u32(uint32_t field, uint32_t bits) {
	return SET_BIT(field, bits);
}
BITOP_FUNC_INLINE uint64_t set_bit_u64(uint64_t field, uint64_t bits) {
	return SET_BIT(field, bits);
}

BITOP_FUNC_INLINE uint clear_bit(uint field, uint bits) {
	return CLEAR_BIT(field, bits);
}
BITOP_FUNC_INLINE uint8_t clear_bit_u8(uint8_t field, uint8_t bits) {
	return CLEAR_BIT(field, bits);
}
BITOP_FUNC_INLINE uint16_t clear_bit_u16(uint16_t field, uint16_t bits) {
	return CLEAR_BIT(field, bits);
}
BITOP_FUNC_INLINE uint32_t clear_bit_u32(uint32_t field, uint32_t bits) {
	return CLEAR_BIT(field, bits);
}
BITOP_FUNC_INLINE uint64_t clear_bit_u64(uint64_t field, uint64_t bits) {
	return CLEAR_BIT(field, bits);
}

BITOP_FUNC_INLINE uint toggle_bit(uint field, uint bits) {
	return TOGGLE_BIT(field, bits);
}
BITOP_FUNC_INLINE uint8_t toggle_bit_u8(uint8_t field, uint8_t bits) {
	return TOGGLE_BIT(field, bits);
}
BITOP_FUNC_INLINE uint16_t toggle_bit_u16(uint16_t field, uint16_t bits) {
	return TOGGLE_BIT(field, bits);
}
BITOP_FUNC_INLINE uint32_t toggle_bit_u32(uint32_t field, uint32_t bits) {
	return TOGGLE_BIT(field, bits);
}
BITOP_FUNC_INLINE uint64_t toggle_bit_u64(uint64_t field, uint64_t bits) {
	return TOGGLE_BIT(field, bits);
}

BITOP_FUNC_INLINE uint modify_bits(uint field, uint mask, uint bits) {
	return MODIFY_BITS(field, mask, bits);
}
BITOP_FUNC_INLINE uint8_t modify_bits_u8(uint8_t field, uint8_t mask, uint8_t bits) {
	return MODIFY_BITS(field, mask, bits);
}
BITOP_FUNC_INLINE uint16_t modify_bits_u16(uint16_t field, uint16_t mask, uint16_t bits) {
	return MODIFY_BITS(field, mask, bits);
}
BITOP_FUNC_INLINE uint32_t modify_bits_u32(uint32_t field, uint32_t mask, uint32_t bits) {
	return MODIFY_BITS(field, mask, bits);
}
BITOP_FUNC_INLINE uint64_t modify_bits_u64(uint64_t field, uint64_t mask, uint64_t bits) {
	return MODIFY_BITS(field, mask, bits);
}

BITOP_FUNC_INLINE uint select_bits(uint field, uint mask) {
	return SELECT_BITS(field, mask);
}
BITOP_FUNC_INLINE uint8_t select_bits_u8(uint8_t field, uint8_t mask) {
	return SELECT_BITS(field, mask);
}
BITOP_FUNC_INLINE uint16_t select_bits_u16(uint16_t field, uint16_t mask) {
	return SELECT_BITS(field, mask);
}
BITOP_FUNC_INLINE uint32_t select_bits_u32(uint32_t field, uint32_t mask) {
	return SELECT_BITS(field, mask);
}
BITOP_FUNC_INLINE uint64_t select_bits_u64(uint64_t field, uint64_t mask) {
	return SELECT_BITS(field, mask);
}

BITOP_FUNC_INLINE uint mask_bits(uint field, uint mask) {
	return MASK_BITS(field, mask);
}
BITOP_FUNC_INLINE uint8_t mask_bits_u8(uint8_t field, uint8_t mask) {
	return MASK_BITS(field, mask);
}
BITOP_FUNC_INLINE uint16_t mask_bits_u16(uint16_t field, uint16_t mask) {
	return MASK_BITS(field, mask);
}
BITOP_FUNC_INLINE uint32_t mask_bits_u32(uint32_t field, uint32_t mask) {
	return MASK_BITS(field, mask);
}
BITOP_FUNC_INLINE uint64_t mask_bits_u64(uint64_t field, uint64_t mask) {
	return MASK_BITS(field, mask);
}

BITOP_FUNC_INLINE uint gather_bits(uint field, uint mask, uint_fast8_t offset) {
	return GATHER_BITS(field, mask, offset);
}
BITOP_FUNC_INLINE uint8_t gather_bits_u8(uint8_t field, uint8_t mask, uint_fast8_t offset) {
	return GATHER_BITS(field, mask, offset);
}
BITOP_FUNC_INLINE uint16_t gather_bits_u16(uint16_t field, uint16_t mask, uint_fast8_t offset) {
	return GATHER_BITS(field, mask, offset);
}
BITOP_FUNC_INLINE uint32_t gather_bits_u32(uint32_t field, uint32_t mask, uint_fast8_t offset) {
	return GATHER_BITS(field, mask, offset);
}
BITOP_FUNC_INLINE uint64_t gather_bits_u64(uint64_t field, uint64_t mask, uint_fast8_t offset) {
	return GATHER_BITS(field, mask, offset);
}

BITOP_FUNC_INLINE bool bit_is_set(uint field, uint mask) {
	return BIT_IS_SET(field, mask);
}
BITOP_FUNC_INLINE bool bit_is_set_u8(uint8_t field, uint8_t mask) {
	return BIT_IS_SET(field, mask);
}
BITOP_FUNC_INLINE bool bit_is_set_u16(uint16_t field, uint16_t mask) {
	return BIT_IS_SET(field, mask);
}
BITOP_FUNC_INLINE bool bit_is_set_u32(uint32_t field, uint32_t mask) {
	return BIT_IS_SET(field, mask);
}
BITOP_FUNC_INLINE bool bit_is_set_u64(uint64_t field, uint64_t mask) {
	return BIT_IS_SET(field, mask);
}

BITOP_FUNC_INLINE bool bits_are_set(uint field, uint mask) {
	return BITS_ARE_SET(field, mask);
}
BITOP_FUNC_INLINE bool bits_are_set_u8(uint8_t field, uint8_t mask) {
	return BITS_ARE_SET(field, mask);
}
BITOP_FUNC_INLINE bool bits_are_set_u16(uint16_t field, uint16_t mask) {
	return BITS_ARE_SET(field, mask);
}
BITOP_FUNC_INLINE bool bits_are_set_u32(uint32_t field, uint32_t mask) {
	return BITS_ARE_SET(field, mask);
}
BITOP_FUNC_INLINE bool bits_are_set_u64(uint64_t field, uint64_t mask) {
	return BITS_ARE_SET(field, mask);
}

BITOP_FUNC_INLINE uint as_bit(uint_fast8_t n) {
	return (uint )1U << n;
}
BITOP_FUNC_INLINE uint8_t as_bit_u8(uint_fast8_t n) {
	return (uint8_t )1U << n;
}
BITOP_FUNC_INLINE uint16_t as_bit_u16(uint_fast8_t n) {
	return (uint16_t )1U << n;
}
BITOP_FUNC_INLINE uint32_t as_bit_u32(uint_fast8_t n) {
	return (uint32_t )1U << n;
}
BITOP_FUNC_INLINE uint64_t as_bit_u64(uint_fast8_t n) {
	return (uint64_t )1U << n;
}

BITOP_FUNC_INLINE uint lowest_bit(uint field) {
	return LOWEST_BIT(field);
}
BITOP_FUNC_INLINE uint8_t lowest_bit_u8(uint8_t field) {
	return LOWEST_BIT(field);
}
BITOP_FUNC_INLINE uint16_t lowest_bit_u16(uint16_t field) {
	return LOWEST_BIT(field);
}
BITOP_FUNC_INLINE uint32_t lowest_bit_u32(uint32_t field) {
	return LOWEST_BIT(field);
}
BITOP_FUNC_INLINE uint64_t lowest_bit_u64(uint64_t field) {
	return LOWEST_BIT(field);
}

BITOP_FUNC_INLINE uint shift_lowest_bit(uint field) {
	return (field / (field & (uint )-field));
}
BITOP_FUNC_INLINE uint8_t shift_lowest_bit_u8(uint8_t field) {
	return (field / (field & (uint8_t )-field));
}
BITOP_FUNC_INLINE uint16_t shift_lowest_bit_u16(uint16_t field) {
	return (field / (field & (uint16_t )-field));
}
BITOP_FUNC_INLINE uint32_t shift_lowest_bit_u32(uint32_t field) {
	return (field / (field & (uint32_t )-field));
}
BITOP_FUNC_INLINE uint64_t shift_lowest_bit_u64(uint64_t field) {
	return (field / (field & (uint64_t )-field));
}


#endif // ULIB_ENABLE_BITOPS
#ifdef __cplusplus
 }
#endif
